-file("erlang/src/bead.erl", 1).

-module(bead).

-compile(export_all).

worker(V1, V2, V3) ->
    collect:track(worker__(collect:track(V1,
                                         [{dom, 1, 3},
                                          {name, "worker", 3}]),
                           collect:track(V2,
                                         [{dom, 2, 3},
                                          {name, "worker", 3}]),
                           collect:track(V3,
                                         [{dom, 3, 3},
                                          {name, "worker", 3}])),
                  [{rng, 3}, {name, "worker", 3}]).

worker__(Pid, F, E) ->
    case F(E) of
        true ->
            Pid ! {true, E};
        _ ->
            Pid ! false
    end.

collector(V1, V2, V3) ->
    collect:track(collector__(collect:track(V1,
                                            [{dom, 1, 3},
                                             {name, "collector", 3}]),
                              collect:track(V2,
                                            [{dom, 2, 3},
                                             {name, "collector", 3}]),
                              collect:track(V3,
                                            [{dom, 3, 3},
                                             {name, "collector", 3}])),
                  [{rng, 3}, {name, "collector", 3}]).

collector__(MainPid, FinishedNum, MaxNum) ->
    receive
        {true, E} ->
            MainPid ! {true, E};
        false ->
            if
                FinishedNum >= MaxNum ->
                    MainPid ! false;
                true ->
                    collector__(MainPid,
                                collect:track(FinishedNum + 1,
                                              [{dom, 2, 3},
                                               {name, "collector", 3}]),
                                MaxNum)
            end
    end.

rev(V1) ->
    collect:track(rev__(collect:track(V1,
                                      [{dom, 1, 1}, {name, "rev", 1}])),
                  [{rng, 1}, {name, "rev", 1}]).

rev__(L) when is_list(L) ->
    rev(L, []).

rev(V1, V2) ->
    collect:track(rev__(collect:track(V1,
                                      [{dom, 1, 2}, {name, "rev", 2}]),
                        collect:track(V2,
                                      [{dom, 2, 2}, {name, "rev", 2}])),
                  [{rng, 2}, {name, "rev", 2}]).

rev__([H | T], Acc) ->
    rev__(T, collect:track([H | Acc], [{dom, 2, 2}, {name, "rev", 2}]));
rev__([], Acc) ->
    Acc.

dup(V1) ->
    collect:track(dup__(collect:track(V1,
                                      [{dom, 1, 1}, {name, "dup", 1}])),
                  [{rng, 1}, {name, "dup", 1}]).

dup__([H | T]) ->
    [{H, H} | dup__(T)];
dup__([]) ->
    [].

len(V1) ->
    collect:track(len__(collect:track(V1,
                                      [{dom, 1, 1}, {name, "len", 1}])),
                  [{rng, 1}, {name, "len", 1}]).

len__([_ | T]) ->
    1 + len__(T);
len__([]) ->
    0.

pany(V1, V2) ->
    collect:track(pany__(collect:track(V1,
                                       [{dom, 1, 2}, {name, "pany", 2}]),
                         collect:track(V2,
                                       [{dom, 2, 2}, {name, "pany", 2}])),
                  [{rng, 2}, {name, "pany", 2}]).

pany__(F, L) ->
    MyPid = self(),
    Collector =
        spawn(fun() ->
                     collector(MyPid, 0, lists:flatlength(L))
              end),
    Pids =
        [ 
         spawn(fun() ->
                      worker(Collector, F, E)
               end) ||
             E <- L
        ],
    Collector,
    receive
        false ->
            false;
        {true, Res} ->
            [ 
             exit(P, normal) ||
                 P <- Pids
            ],
            {true, Res}
    end.

test(V1) ->
    collect:track(test__(collect:track(V1,
                                       [{dom, 1, 1}, {name, "test", 1}])),
                  [{rng, 1}, {name, "test", 1}]).

test__(L) ->
    lists:sort(L).



